<!DOCTYPE html>
<html>
<head>
  <script src="prism.js"></script>
  <script src="jquery.js"></script>
  <script src="selection.js"></script>
  <script src="prism-md.js"></script>
  <link rel="stylesheet" href="prism.css">
  <style>

  .token.heading { font-weight: bold; }
  .token.heading .heading-hash { font-weight: normal; }
  .token.heading .heading-setext-line { font-weight: normal; }
  .token.heading.heading-1 { font-size: 2em; }
  .token.heading.heading-2 { font-size: 1.75em; }
  .token.heading.heading-3 { font-size: 1.5em; }
  .token.heading.heading-4 { font-size: 1.3em; }
  .token.heading.heading-5 { font-size: 1.2em; }
  .token.heading.heading-6 { font-size: 1.15em; }
  .token.marker { color: rgba(120,120,120,0.5); }
  .token.strong { font-weight: bold; }
  .token.em { font-style: italic; }
  .token.strike-inner { text-decoration: line-through }
  .token.code { background: rgba(120,120,120,0.1); padding: 0.15em 0; }
  .token.href, .token.braced-href .braced-href-inner { color: rgba(120,120,120,0.8); }
  .token.blockquote-content { color: #555; }

  /* nice debugging styles */
  /*.token {
    border: 1px solid red;
    padding: 10px;
  }
  .token>.token { padding: 8px }
  .token>.token>.token { padding: 6px }
  .token>.token>.token>.token { padding: 4px }
  .token>.token>.token>.token>.token { padding: 2px }
  .token>.token>.token>.token>.token>.token { padding: 0px }*/
  /*.token:before {
    content: attr(class);
    font-size: 0.1em;
  }*/

  </style>
</head>
<body>

<pre class="language-md" contenteditable>

# H1

## H2

### H3

#### H4

##### H5

##### H6

## H2 with trailing hashes ##



  ### H3 with some leading space


     # H1 indented too far


seText-style H1
======



seText-style H2
------


  unaligned H1
=


unaligned h2
  --


h1 indented too far
     =




not an hr:

===


this is an hr:

***

and this:

---

and this:

___


and this:

 *    *  * * ** **

not this:

 * _ *




**strong** stuff

__strong
stuff__


**not strong

stuff**




Here is some _emphatic_ stuff


*emphatic
stuff I say!*


_not

very emphatic_






Here is a **strong, *emphatic* thing**.

And **another *one***

And ***another one!***

And **_this_ one too**

And __this *one*__

This __is **silly though**__


Here is an _emphatic, **strong** thing_

And _another __one___

And *another **one***


~~deleted stuff~~


 * list
 * listy
 * listy

 1. num
 *  bered
 *  lists
    moar
 *  blah


 * **formatting** _in_ ~~lists~~ please with `code` and stuff
   * nesting?
   * maybe
   * too?



`code`

Lots of text with `code` in it

Code `has no *stuff inside it*`.

# Even `headings` can have code _and other_ **things**





[link](aaaa)

[link](&lt;aaa&gt;)

[link](aaaa "title")

[link](aaaa(foo) "tit\"le")

[link](&lt;blahblah&gt; 'som"e"thing')


![IMAGE](image)

![IMAGE](&lt;aaa&gt;)

![IMAGE](aaaa "title")

![IMAGE](aaaa(foo) "tit\"le")

![IMAGE](&lt;blahblah&gt; 'som"e"thing')



[link **with** _somme_ `formatting`](foo)

![image **with** _some_ `formatting`](bar)


This probably won't work:

[link with ![an image](foo)](bar)



> blockquote



> blockquote
> long
> long
> blockquote

> blockquote
  with
  lazy
coninutation
> and picking
> back up
agan

> * list
  * inside
  * blockquote
  * omg

---
Still to do:

 * footnotes
 * link references / defs
 * image references / defs
 * fenced
 * fenced with language
 * embedded html


Bigger stuff:

 * Tweak Prism for a better concept of ordering and precedence
</pre>

<script>

var el = $('pre')[0];

el.onkeyup = function(evt){
  var keyCode = evt && evt.keyCode || 0,
      code = this.textContent;

  if(keyCode < 9 || keyCode == 13 || keyCode > 32 && keyCode < 41) {
    // $t.trigger('caretmove');
  }

  if([
    9, 91, 93, 16, 17, 18, // modifiers
    20, // caps lock
    13, // Enter (handled by keydown)
    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, // F[0-12]
    27 // Esc
  ].indexOf(keyCode) > -1) {
    return;
  }

  if([
		37, 39, 38, 40 // Left, Right, Up, Down
	].indexOf(keyCode) === -1) {
    // $t.trigger('contentchange', {
    //   keyCode: keyCode
    // });
    this.oninput();
  }
};

el.oninput = function(evt){
  var code = this.textContent;

  var ss = this.selectionStart,
    se = this.selectionEnd;

  Prism.highlightElement(this);

  // Dirty fix to #2
  if(!/\n$/.test(code)) {
    this.innerHTML = this.innerHTML + '\n';
  }

  if(ss !== null || se !== null) {
    this.setSelectionRange(ss, se);
  }
};

el.onkeydown = function(evt){
  var cmdOrCtrl = evt.metaKey || evt.ctrlKey;

  switch(evt.keyCode) {
    case 8: // Backspace
      // var ss = this.selectionStart,
      //   se = this.selectionEnd,
      //   length = ss === se? 1 : Math.abs(se - ss),
      //   start = se - length;
      //
      // that.undoManager.action({
      //   add: '',
      //   del: this.textContent.slice(start, se),
      //   start: start
      // });
      //
      break;
    case 9: // Tab
      // if(!cmdOrCtrl) {
      //   that.action('indent', {
      //     inverse: evt.shiftKey
      //   });
      //   return false;
      // }
      break;
    case 13:
      action('newline');
      evt.preventDefault();
      return false;
    case 90:
      // if(cmdOrCtrl) {
      //   that.undoManager[evt.shiftKey? 'redo' : 'undo']();
      //   return false;
      // }

      break;
    case 191:
      // if(cmdOrCtrl && !evt.altKey) {
      //   that.action('comment', { lang: this.id });
      //   return false;
      // }

      break;
  }
};

function action(act, opts){
  var p = el;
  opts = opts || {};
  var text = p.textContent;
  var start = opts.start || p.selectionStart;
  var end = opts.end || p.selectionEnd;

  var state = {
    start: start,
    end: end,
    before: text.slice(0, start),
    after: text.slice(end),
    sel: text.slice(start, end)
  };

  var a = actions[act](state, opts);

  p.textContent = state.before + state.sel + state.after;

  p.setSelectionRange(state.start, state.end);
  p.onkeyup();
}

var actions = {
  newline: function(state, options){//NB leading newline goes weird
    var s = state.start;
    state.before += '\n';

    var sel = state.sel;
    state.sel = '';

    state.start += 1;
    state.end = state.start;

    return { add: '\n', del: sel, start: s };
  }
};


el.onkeyup();

</script>

</body>
</html>
